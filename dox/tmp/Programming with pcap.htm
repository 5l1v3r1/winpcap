<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0031)http://www.tcpdump.org/pcap.htm -->
<HTML><HEAD><TITLE>Programming with pcap</TITLE>
<META http-equiv=Content-Language content=en-us>
<META content="MSHTML 5.50.4807.2300" name=GENERATOR>
<META content=FrontPage.Editor.Document name=ProgId>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"></HEAD>
<BODY>
<P><FONT face=Verdana>Programming with pcap<BR><FONT size=2>Tim 
Carstens<BR>timcarst <B>at</B> yahoo <B>dot</B> com<BR>The latest version of 
this document can be found at http://broker.dhs.org/pcap.html</FONT></FONT></P>
<P><FONT face=Verdana size=1>Ok, lets begin by defining who this document is 
written for.&nbsp; Obviously, some basic knowledge of C is required, unless you 
only wish to know the basic theory.&nbsp; You do not need to be a code ninja; 
for the areas likely to be understood only by more experienced programmers, I'll 
be sure to describe concepts in greater detail.&nbsp; Additionally, some basic 
understanding of networking might help, given that this is a packet sniffer and 
all.&nbsp; All of the code examples presented here have been tested on FreeBSD 
4.3 with a default kernel.</FONT></P>
<P><FONT face=Verdana size=2>Getting Started: The format of a pcap 
application<BR></FONT><FONT face=Verdana size=1>The first thing to understand is 
the general layout of a pcap sniffer.&nbsp; The flow of code is as 
follows:</FONT></P>
<OL style="FONT-SIZE: 8pt; FONT-FAMILY: Verdana">
  <LI><FONT size=1>We begin by determining which interface we want to sniff 
  on.&nbsp; In Linux this may be something like eth0, in BSD it may be xl1, 
  etc.&nbsp; We can either define this device in a string, or we can as pcap to 
  provide us with the name of an interface that will do the job.</FONT> 
  <LI><FONT size=1>Initialize pcap.&nbsp; This is where we actually tell pcap 
  what device we are sniffing on.&nbsp; We can, if we want to, sniff on multiple 
  devices.&nbsp; How do we differentiate between them?&nbsp; Using file 
  handles.&nbsp; Just like opening a file for reading or writing, we must name 
  our sniffing "session" so we can tell it apart from other such 
  sessions.</FONT> 
  <LI><FONT size=1>In the event that we only want to sniff specific traffic 
  (e.g.: only TCP/IP packets, only packets going to port 23, etc) we must create 
  a rule set, "compile" it, and apply it.&nbsp; This is a three phase process, 
  all of which is closely related.&nbsp; The rule set is kept in a string, and 
  is converted into a format that pcap can read (hence compiling it.)&nbsp; The 
  compilation is actually just done by calling a function within our program; it 
  does not involve the use of an external application.&nbsp; Then we tell pcap 
  to apply it to whichever session we wish for it to filter.</FONT> 
  <LI><FONT size=1>Finally, we tell pcap to enter it's primary execution 
  loop.&nbsp; In this state, pcap waits until it has received however many 
  packets we want it to.&nbsp; Every time it gets a new packet in, it calls 
  another function that we have already defined.&nbsp; The function that it 
  calls can do anything we want; it can dissect the packet and print it to the 
  user, it can save it in a file, or it can do nothing at all.</FONT> 
  <LI><FONT size=1>After our sniffing needs are satisfied, we close our session 
  and are complete.</FONT> </LI></OL>
<P><FONT size=1><SPAN style="FONT-FAMILY: Verdana">This is actually a very 
simple process.&nbsp; Five steps total, one of which is optional (step 3, incase 
you were wondering.)&nbsp; Why don't we take a look at each of the steps and how 
to implement them.</SPAN></FONT></P>
<P><SPAN style="FONT-FAMILY: Verdana"><FONT size=2>Setting the 
devise<BR></FONT><FONT size=1>This is terribly simple.&nbsp; There are two 
techniques for setting the device that we wish to sniff on.</FONT></SPAN></P>
<P><FONT size=1><SPAN style="FONT-FAMILY: Verdana">The first is that we can 
simply have the user tell us.&nbsp; Consider the following program:<BR>#include 
&lt;stdio.h&gt;<BR>#include &lt;pcap.h&gt;<BR>int main(int argc, char 
*argv[])<BR>{<BR>&nbsp;&nbsp;&nbsp; char *dev = argv[1];<BR>&nbsp;&nbsp;&nbsp; 
printf("Device: %s\n", dev);<BR>&nbsp;&nbsp;&nbsp; return(0);<BR>}<BR>The user 
specifies the device by passing the name of it as the first argument to the 
program.&nbsp; Now the string "dev" holds the name of the interface that we will 
sniff on in a format that pcap can understand (assuming, of course, the user 
gave us a real interface).</SPAN></FONT></P>
<P><FONT size=1><SPAN style="FONT-FAMILY: Verdana">The other technique is 
equally simply.&nbsp; Look at this program:<BR>#include 
&lt;stdio.h&gt;<BR>#include &lt;pcap.h&gt;<BR>int 
main()<BR>{<BR>&nbsp;&nbsp;&nbsp; char *dev, 
errbuf[PCAP_ERRBUF_SIZE];<BR>&nbsp;&nbsp;&nbsp; dev = 
pcap_lookupdev(errbuf);<BR>&nbsp;&nbsp;&nbsp; printf("Device: %s\n", 
dev);<BR>&nbsp;&nbsp;&nbsp; return(0);<BR>}<BR>In this case, pcap just sets the 
device on its own.&nbsp; "But wait Tim," you say.&nbsp; "What is the deal with 
the errbuf string?"&nbsp; Most of the pcap commands allow us to pass them a 
string as an argument.&nbsp; The purpose of this string?&nbsp; In the event that 
the command fails, it will populate the string with a description of the 
error.&nbsp; In this case, if pcap_lookupdev() fails, it will store an error 
message in errbuf.&nbsp; Nifty, isn't it?&nbsp; And that's how we set our 
device.</SPAN></FONT></P>
<P><SPAN style="FONT-FAMILY: Verdana"><FONT size=2>Opening the device for 
sniffing<BR></FONT><FONT size=1>The task of creating a sniffing session is 
really quite simple.&nbsp; For this, we use pcap_open_live().&nbsp; The 
prototype of this function (from the pcap man page) is as follows:<BR>pcap_t 
*pcap_open_live(char *device, int snaplen, int promisc, int to_ms, char 
*ebuf)<BR>The first argument is the device that we specified in the previous 
section.&nbsp; snaplen is an integer which defines the maximum number of bytes 
to be captured by pcap.&nbsp; promisc, when set to true, brings the interface 
into promiscuous mode (however, even if it is set to false, it is possible under 
specific cases for the interface to be in promiscuous mode, anyway).&nbsp; to_ms 
is the read time out in milliseconds (a value of 0 sniffs until an error occurs; 
-1 sniffs indefinitely).&nbsp; Lastly, ebuf is a string we can store any error 
messages within (as we did above with errbuf).&nbsp; The function returns our 
session handler.</FONT></SPAN></P>
<P><FONT size=1><SPAN style="FONT-FAMILY: Verdana">To demonstrate, consider this 
code snippet:<BR>&nbsp;&nbsp;&nbsp; #include 
&lt;pcap.h&gt;<BR>&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; pcap_t 
*handle;<BR>&nbsp;&nbsp;&nbsp; handle = pcap_open_live(somedev, BUFSIZ, 1, 0, 
errbuf);<BR>This code fragment opens the devise stored in the strong "somedev", 
tells it to read however many bytes are specified in BUFSIZ (which is defined in 
pcap.h).&nbsp; We are telling it to put the device into promiscuous mode, to 
sniff until an error occurs, and if there is an error, store it in the string 
errbuf.</SPAN></FONT></P>
<P><FONT size=1><SPAN style="FONT-FAMILY: Verdana">A note about promiscuous vs. 
non-promiscuous sniffing:&nbsp; The two techniques are very different in 
style.&nbsp; In standard, non-promiscuous sniffing, a host is sniffing only 
traffic that is directly related to it.&nbsp; Only traffic to, from, or routed 
through the host will be picked up by the sniffer.&nbsp; Promiscuous mode, on 
the other hand, sniffs all traffic on the wire.&nbsp; In a non-switched 
environment, this could be all network traffic.&nbsp; The obvious advantage to 
this is that it provides more packets for sniffing, which may or may not be 
helpful depending on the reason you are sniffing the network.&nbsp; However, 
there are regressions.&nbsp; Promiscuous mode sniffing is detectable; a host can 
test with strong reliability to determine if another host is doing promiscuous 
sniffing.&nbsp; Second, it only works in a non-switched environment (such as a 
hub, or a switch that is being ARP flooded).&nbsp; Third, on high traffic 
networks, the host can become quite taxed for system 
resources.</SPAN></FONT></P>
<P><FONT size=2><SPAN style="FONT-FAMILY: Verdana">Filtering 
traffic</SPAN></FONT><FONT face=Verdana><BR><FONT size=1>Often times our sniffer 
may only be interested in specific traffic.&nbsp; For instance, there may be 
times when all we want is to sniff on port 23 (telnet) in search of 
passwords.&nbsp; Or perhaps we want to highjack a file being sent over port 21 
(FTP).&nbsp; Maybe we only want DNS traffic (port 53 UDP). Whatever the case, 
rarely do we just want to blindly sniff <I>all</I> network traffic.&nbsp; Enter 
pcap_compile() and pcap_setfilter().</FONT></FONT></P>
<P><FONT face=Verdana size=1>The process is quite simple.&nbsp; After we have 
already called pcap_open_live() and have a working sniffing session, we can 
apply our filter.&nbsp; Why not just use our own if/else if statements?&nbsp; 
Two reasons.&nbsp; First, pcap's filter is far more efficient, because it does 
it directly with the BPF filter; we eliminate numerous steps by having the BPF 
driver do it directly.&nbsp; Second, this is a <I>lot</I> easier :)</FONT></P>
<P><FONT face=Verdana size=1>Before applying our filter, we must "compile" 
it.&nbsp; The filter expression is kept in a regular string (char array).&nbsp; 
The syntax is documented quite well in the man page for tcpdump; I leave you to 
read it on your own.&nbsp; However, we will use simple test expressions, so 
perhaps you are sharp enough to figure it out from my examples.</FONT></P>
<P><FONT face=Verdana size=1>To compile the program we call 
pcap_compile().&nbsp; The prototype defines it as:<BR>int pcap_compile(pcap_t 
*p, struct bpf_program *fp, char *str, int optimize, bpf_u_int32 netmask)<BR>The 
first argument is our session handle (pcap_t *handle in our previous 
example).&nbsp; Following that is a reference to the place we will store the 
compiled version of our filter.&nbsp; Then comes the expression itself, in 
regular string format.&nbsp; Next is an integer that decides if the expression 
should be "optimized" or not (0 is false, 1 is true.&nbsp; Standard 
stuff.)&nbsp; Finally, we must specify the net mask of the network the filter 
applies to.&nbsp; The function returns -1 on failure; all other values imply 
success.</FONT></P>
<P><FONT face=Verdana size=1>After the expression has been compiled, it is time 
to apply it.&nbsp; Enter pcap_setfilter().&nbsp; Following our format of 
explaining pcap, we shall look at the pcap_setfilter() prototype:<BR>int 
pcap_setfilter(pcap_t *p, struct bpf_program *fp)<BR>This is very strait 
forward.&nbsp; The first argument is our session handler, the second is a 
reference to the compiled version of the expression (presumably the same 
variable as the second argument to pcap_compile()).</FONT></P>
<P><FONT face=Verdana size=1>Perhaps another code sample would help to better 
understand:<BR>&nbsp;&nbsp;&nbsp; #include &lt;pcap.h&gt;<BR>&nbsp;&nbsp;&nbsp; 
...<BR>&nbsp;&nbsp;&nbsp; pcap_t 
*handle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* Session handle */<BR>&nbsp;&nbsp;&nbsp; char dev[] = 
"rl0";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* Device to sniff on */<BR>&nbsp;&nbsp;&nbsp; char 
errbuf[PCAP_ERRBUF_SIZE];&nbsp;&nbsp;&nbsp; /* Error string 
*/<BR>&nbsp;&nbsp;&nbsp; struct bpf_program 
filter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* The compiled filter expression */<BR>&nbsp;&nbsp;&nbsp; char filter_app[] = 
"port 23";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The filter 
expression */<BR>&nbsp;&nbsp;&nbsp; bpf_u_int32 
mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* The netmask of our sniffing device */<BR>&nbsp;&nbsp;&nbsp; bpf_u_int32 
net;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* The IP of our sniffing device */<BR>&nbsp;&nbsp;&nbsp; pcap_lookupnet(dev, 
&amp;net, &amp;mask, errbuf);<BR>&nbsp;&nbsp;&nbsp; handle = pcap_open_live(dev, 
BUFSIZ, 1, 0, errbuf);<BR>&nbsp;&nbsp;&nbsp; pcap_compile(handle, &amp;filter, 
filter_app, 0, net);<BR>&nbsp;&nbsp;&nbsp; pcap_setfilter(handle, 
&amp;filter);<BR>This program preps the sniffer to sniff all traffic coming from 
or going to port 23, in promiscuous mode, on the device rl0.</FONT></P>
<P><FONT face=Verdana size=1>You may notice that the previous example contains a 
function that we have not yet discussed.&nbsp; pcap_lookupnet() is a function 
that, given the name of a device, returns its IP and net mask.&nbsp; This was 
essential because we needed to know the net mask in order to apply the 
filter.&nbsp; This function is described in the Miscellaneous section at the end 
of the document.</FONT></P>
<P><FONT face=Verdana size=1>It has been my experience that this filter does not 
work across all operating systems.&nbsp; In my test environment, I found that 
OpenBSD 2.9 with a default kernel does support this type of filter, but FreeBSD 
4.3 with a default kernel does not.&nbsp; Your mileage may vary.</FONT></P>
<P><FONT face=Verdana><FONT size=2>The actual sniffing<BR></FONT><FONT size=1>At 
this point we have learned how to define a device, prepare it for sniffing, and 
apply filters about what we should and should not sniff for.&nbsp; Now it is 
time to actually capture some packets.</FONT></FONT></P>
<P><FONT face=Verdana size=1>There are two main techniques for capturing 
packets.&nbsp; We can either capture a single packet at a time, or we can enter 
a loop that waits for <I>n</I> number of packets to be sniffed before being 
done.&nbsp; We will begin by looking at how to capture a single packet, then 
look at methods of using loops.&nbsp; For this we use pcap_next().</FONT></P>
<P><FONT face=Verdana size=1>The prototype for pcap_next() fairly 
simple:<BR>u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h)<BR>The first 
argument is our session handler.&nbsp; The second argument is a pointer to a 
structure that holds general information about the packet, specifically the time 
in which it was sniffed, the length of this packet, and the length of his 
specific portion (incase it is fragmented, for example.)&nbsp; pcap_next() 
returns a u_char pointer to the packet that is described by this 
structure.&nbsp; We'll discuss the technique for actually reading the packet 
itself later.</FONT></P>
<P><FONT face=Verdana size=1>Here is a simple demonstration of using pcap_next() 
to sniff a packet.<BR>&nbsp;&nbsp;&nbsp; #include 
&lt;pcap.h&gt;<BR>&nbsp;&nbsp;&nbsp; #include 
&lt;stdio.h&gt;<BR>&nbsp;&nbsp;&nbsp; int main()<BR>&nbsp;&nbsp;&nbsp; 
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcap_t 
*handle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* Session handle */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char 
*dev;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* The device to sniff on */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char 
errbuf[PCAP_ERRBUF_SIZE]; /* Error string 
*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct bpf_program 
filter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The 
compiled filter */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char 
filter_app[] = "port 23";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The filter 
expression */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bpf_u_int32 
mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* Our netmask */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bpf_u_int32 
net;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* Our IP */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct pcap_pkthdr 
header;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The header that 
pcap gives us */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const u_char 
*packet;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
/* The actual packet */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Define 
the device */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev = 
pcap_lookupdev(errbuf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Find 
the properties for the device */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
pcap_lookupnet(dev, &amp;net, &amp;mask, 
errbuf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Open the session in 
promiscuous mode */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = 
pcap_open_live(dev, BUFSIZ, 1, 0, 
errbuf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Compile and apply the 
filter */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcap_compile(handle, 
&amp;filter, filter_app, 0, net);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
pcap_setfilter(handle, 
&amp;filter);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Grab a packet 
*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; packet = pcap_next(handle, 
&amp;header);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Print its length 
*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Jacked a packet with 
length of [%d]\n", header.len);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 
And close the session */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
pcap_close(handle);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
return(0);<BR>&nbsp;&nbsp;&nbsp; }<BR>This application sniffs on whatever device 
is returned by pcap_lookupdev() by putting it into promiscuous mode.&nbsp; It 
finds the first packet to come across port 23 (telnet) and tells the user the 
size of the packet (in bytes).&nbsp; Again, this program includes a new call, 
pcap_close(), which we will discuss later (although it really is quite self 
explanatory).</FONT></P>
<P><FONT face=Verdana size=1>The other technique we can use is more complicated, 
and probably more useful.&nbsp; Few sniffers (if any) actually use 
pcap_next().&nbsp; More often than not, they use pcap_loop() or pcap_dispatch() 
(which then themselves use pcap_loop()).&nbsp; To understand the use of these 
two functions, you must understand the idea of a callback function.</FONT></P>
<P><FONT face=Verdana size=1>Callback functions are not anything new, and are 
very common in many API's.&nbsp; The concept behind a callback function is 
fairly simple.&nbsp; Suppose I have a program that is waiting for an event of 
some sort.&nbsp; For the purpose of this example, lets pretend that my program 
wants a user to press a key on the keyboard.&nbsp; Every time they press a key, 
I want to call a function which then will determine that to do.&nbsp; The 
function I am utilizing is a callback function.&nbsp; Every time the user 
presses a key, my program will call the callback function.&nbsp; Callbacks are 
used in pcap, but instead of being called when a user presses a key, they are 
called when pcap sniffs a packet.&nbsp; The two functions that one can use to 
define their callback is pcap_loop() and pcap_dispatch().&nbsp; pcap_loop() and 
pcap_dispatch() are very similar in their usage of callbacks.&nbsp; Both of them 
call a callback function every time a packet is sniffed that meets our filter 
requirements (if any filter exists, of course.&nbsp; If not, then <I>all</I> 
packets that are sniffed are sent to the callback.)</FONT></P>
<P><FONT face=Verdana size=1>The prototype for pcap_loop() is below:<BR>int 
pcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)<BR>The first 
argument is our session handle.&nbsp; Following that is an integer that tells 
pcap_loop() how many packets it should sniff for before returning (a negative 
value means it should sniff until an error occurs).&nbsp; The third argument is 
the name of the callback function (just it's identifier, no 
parenthesizes).&nbsp; The last argument is useful in some applications, but many 
times is simply set as NULL.&nbsp; Suppose we have arguments of our own that we 
wish to send to our callback function, in addition to the arguments that 
pcap_loop() sends.&nbsp; This is where we do it.&nbsp; Obviously, you must 
typecast to a u_char pointer to ensure the results make it there correctly; as 
we will see later, pcap makes use of some very interesting means of passing 
information in the form of a u_char pointer.&nbsp; After we show an example of 
how pcap does it, it should be obvious how to do it here.&nbsp; If not, consult 
your local C reference text, as an explanation of pointers is beyond the scope 
of this document.&nbsp; pcap_dispatch() is almost identical in usage.&nbsp; The 
only difference between pcap_dispatch() and pcap_loop() is in how they handle 
timeouts (remember how you could set a timeout when you called 
pcap_open_live()?&nbsp; This is where it comes into play.&nbsp; pcap_loop() 
ignores the timeout while pcap_dispatch() does not.&nbsp; For a more in depth 
discussion of their differences, see the pcap man page.</FONT></P>
<P><FONT face=Verdana size=1>Before we can provide an example of using 
pcap_loop(), we must examine the format of our callback function.&nbsp; We 
cannot arbitrarily define our callback's prototype; otherwise, pcap_loop() would 
not know how to use the function.&nbsp; So we use this format as the prototype 
for our callback function:<BR>void got_packet(u_char *args, const struct 
pcap_pkthdr *header, const u_char *packet);<BR>Lets examine this in more 
detail.&nbsp; First, you'll notice that the function has a void return 
type.&nbsp; This is logical, because pcap_loop() wouldn't know how to handle a 
return value anyway.&nbsp; The first argument corresponds to the last argument 
of pcap_loop().&nbsp; Whatever value is passed as the last argument to 
pcap_loop() is passed to the first argument of our callback function every time 
the function is called.&nbsp; The second argument is the pcap header, which 
contains information about when the packet was sniffed, how large it is, 
etc.&nbsp; The pcap_pkthdr structure is defined in pcap.h as:<BR>struct 
pcap_pkthdr {<BR>&nbsp;&nbsp;&nbsp; struct timeval ts; /* time stamp 
*/<BR>&nbsp;&nbsp;&nbsp; bpf_u_int32 caplen; /* length of portion present 
*/<BR>&nbsp;&nbsp;&nbsp; bpf_u_int32 len; /* length this packet (off wire) */ 
<BR>};<BR>These values should be fairly self explanatory.&nbsp; The last 
argument is the most interesting of them all, and the most confusing to the 
average novice pcap programmer.&nbsp; It is another pointer to a u_char, and it 
contains the entire packet, as sniffed by pcap_loop().</FONT></P>
<P><FONT face=Verdana size=1>But how do you make use of this variable (named 
"packet" in our prototype)?&nbsp; A packet contains many attributes, so as you 
can imagine, it is not really a string, but actually a collection of structures 
(for instance, a TCP/IP packet would have an Ethernet header, an IP header, a 
TCP header, and lastly, the packet's payload).&nbsp; This u_char is the 
serialized version of these structures.&nbsp; To make any use of it, we must do 
some interesting typecasting.</FONT></P>
<P><FONT face=Verdana size=1>First, we must have the actual structures define 
before we can typecast to them.&nbsp; The following is the structure definitions 
that I use to describe a TCP/IP packet over Ethernet.&nbsp; All three 
definitions that I use are taken directly out of the POSIX libraries.&nbsp; 
Normally I would have simply just used the definitions in those libraries, but 
it has been my experience that the libraries vary slightly from platform to 
platform, making it complicated to implement them quickly.&nbsp; So for 
demonstration purposes we will just avoid that mess and simply copy the relevant 
structures.&nbsp; All of these, incidentally, can be found in include/netinet on 
your local Unix system.&nbsp; Here are the structures:<BR>/* Ethernet header 
*/<BR>struct sniff_ethernet {<BR>&nbsp;&nbsp;&nbsp; u_char 
ether_dhost[ETHER_ADDR_LEN]; /* Destination host address 
*/<BR>&nbsp;&nbsp;&nbsp; u_char ether_shost[ETHER_ADDR_LEN]; /* Source host 
address */<BR>&nbsp;&nbsp;&nbsp; u_short ether_type; /* IP? ARP? RARP? etc 
*/<BR>};<BR>/* IP header */<BR>struct sniff_ip {<BR>&nbsp;&nbsp;&nbsp; #if 
BYTE_ORDER == LITTLE_ENDIAN<BR>&nbsp;&nbsp;&nbsp; u_int ip_hl:4, /* header 
length */<BR>&nbsp;&nbsp;&nbsp; ip_v:4; /* version */<BR>&nbsp;&nbsp;&nbsp; #if 
BYTE_ORDER == BIG_ENDIAN<BR>&nbsp;&nbsp;&nbsp; u_int ip_v:4, /* version 
*/<BR>&nbsp;&nbsp;&nbsp; ip_hl:4; /* header length */<BR>&nbsp;&nbsp;&nbsp; 
#endif<BR>&nbsp;&nbsp;&nbsp; #endif /* not _IP_VHL */<BR>&nbsp;&nbsp;&nbsp; 
u_char ip_tos; /* type of service */<BR>&nbsp;&nbsp;&nbsp; u_short ip_len; /* 
total length */<BR>&nbsp;&nbsp;&nbsp; u_short ip_id; /* identification 
*/<BR>&nbsp;&nbsp;&nbsp; u_short ip_off; /* fragment offset field 
*/<BR>&nbsp;&nbsp;&nbsp; #define IP_RF 0x8000 /* reserved fragment flag 
*/<BR>&nbsp;&nbsp;&nbsp; #define IP_DF 0x4000 /* dont fragment flag 
*/<BR>&nbsp;&nbsp;&nbsp; #define IP_MF 0x2000 /* more fragments flag 
*/<BR>&nbsp;&nbsp;&nbsp; #define IP_OFFMASK 0x1fff /* mask for fragmenting bits 
*/<BR>&nbsp;&nbsp;&nbsp; u_char ip_ttl; /* time to live */<BR>&nbsp;&nbsp;&nbsp; 
u_char ip_p; /* protocol */<BR>&nbsp;&nbsp;&nbsp; u_short ip_sum; /* checksum 
*/<BR>&nbsp;&nbsp;&nbsp; struct in_addr ip_src,ip_dst; /* source and dest 
address */<BR>};<BR>/* TCP header */<BR>struct sniff_tcp {<BR>&nbsp;&nbsp;&nbsp; 
u_short th_sport; /* source port */<BR>&nbsp;&nbsp;&nbsp; u_short th_dport; /* 
destination port */<BR>&nbsp;&nbsp;&nbsp; tcp_seq th_seq; /* sequence number 
*/<BR>&nbsp;&nbsp;&nbsp; tcp_seq th_ack; /* acknowledgement number 
*/<BR>&nbsp;&nbsp;&nbsp; #if BYTE_ORDER == LITTLE_ENDIAN<BR>&nbsp;&nbsp;&nbsp; 
u_int th_x2:4, /* (unused) */<BR>&nbsp;&nbsp;&nbsp; th_off:4; /* data offset 
*/<BR>&nbsp;&nbsp;&nbsp; #endif<BR>&nbsp;&nbsp;&nbsp; #if BYTE_ORDER == 
BIG_ENDIAN<BR>&nbsp;&nbsp;&nbsp; u_int th_off:4, /* data offset 
*/<BR>&nbsp;&nbsp;&nbsp; th_x2:4; /* (unused) */<BR>&nbsp;&nbsp;&nbsp; 
#endif<BR>&nbsp;&nbsp;&nbsp; u_char th_flags;<BR>&nbsp;&nbsp;&nbsp; #define 
TH_FIN 0x01<BR>&nbsp;&nbsp;&nbsp; #define TH_SYN 0x02<BR>&nbsp;&nbsp;&nbsp; 
#define TH_RST 0x04<BR>&nbsp;&nbsp;&nbsp; #define TH_PUSH 
0x08<BR>&nbsp;&nbsp;&nbsp; #define TH_ACK 0x10<BR>&nbsp;&nbsp;&nbsp; #define 
TH_URG 0x20<BR>&nbsp;&nbsp;&nbsp; #define TH_ECE 0x40<BR>&nbsp;&nbsp;&nbsp; 
#define TH_CWR 0x80<BR>&nbsp;&nbsp;&nbsp; #define TH_FLAGS 
(TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)<BR>&nbsp;&nbsp;&nbsp; u_short 
th_win; /* window */<BR>&nbsp;&nbsp;&nbsp; u_short th_sum; /* checksum 
*/<BR>&nbsp;&nbsp;&nbsp; u_short th_urp; /* urgent pointer */<BR>};</FONT></P>
<P><FONT face=Verdana size=1><B>Note:</B> On my Slackware Linux 8 box (stock 
kernel 2.2.19) I found that code using the above structures would not 
compile.&nbsp; The problem, as it turns out, was in include/features.h, which 
implements a POSIX interface unless _BSD_SOURCE is defined.&nbsp; If it was not 
defined, then I had to use a different structure definition for the TCP 
header.&nbsp; The more universal solution, that does not prevent the code from 
working on FreeBSD or OpenBSD (where it had previously worked fine), is simply 
to do the following:<BR>#define _BSD_SOURCE 1<BR>prior to including any of your 
header files.&nbsp; This will ensure that a BSD style API is being used.&nbsp; 
Again, if you don't wish to do this, then you can simply use the alternative TCP 
header structure, which I've linked to <A 
href="http://www.tcpdump.org/alt-tcp.c">here</A>, along with some quick notes 
about using it.</FONT></P>
<P><FONT face=Verdana size=1>So how does all of this relate to pcap and our 
mysterious u_char?&nbsp; Well, as luck would have it, pcap uses the <I>exact 
same structures</I> when sniffing packets.&nbsp; Then they simply create a 
u_char string and stuff the structures into it.&nbsp; So how can we break it 
apart?&nbsp; Be prepared to witness one of the most practical uses of pointers 
(for all of those new C programmers who insist that pointers are useless, I 
smite you).</FONT></P>
<P><FONT face=Verdana size=1>Again, we're going to assume that we are dealing 
with a TCP/IP packet over Ethernet.&nbsp; This same technique applies to any 
packet; the only difference is the structure types that you actually use.&nbsp; 
So lets begin by declaring the variables we will need to deconstruct the packet 
u_char.</FONT></P>
<P><FONT face=Verdana size=1>const struct sniff_ethernet *ethernet; /* The 
ethernet header */<BR>const struct sniff_ip *ip; /* The IP header */<BR>const 
struct sniff_tcp *tcp; /* The TCP header */<BR>const char *payload; /* Packet 
payload */<BR>/* For readability, we'll make variables for the sizes of each of 
the structures */<BR>int size_ethernet = sizeof(struct sniff_ethernet);<BR>int 
size_ip = sizeof(struct sniff_ip);<BR>int size_tcp = sizeof(struct 
sniff_tcp);</FONT></P>
<P><FONT face=Verdana size=1>And now we do our magical typecasting:<BR>ethernet 
= (struct sniff_ethernet*)(packet);<BR>ip = (struct sniff_ip*)(packet + 
size_ethernet);<BR>tcp = (struct sniff_tcp*)(packet + size_ethernet + 
size_ip);<BR>payload = (u_char *)(packet + size_ethernet + size_ip + 
size_tcp);</FONT></P>
<P><FONT face=Verdana size=1>How does this work?&nbsp; Consider the layout of 
the packet u_char in memory.&nbsp; Basically, all that has happened when pcap 
stuffed these structures into a u_char is that all of the data contained within 
them was put in a string, and that string was sent to our callback.&nbsp; The 
convenient thing is that, regardless of the values set to these structures, 
their sizes always remains the same.&nbsp; On my workstation, for instance, a 
sniff_ethernet structure has a size of 14 bytes.&nbsp; a sniff_ip structure is 
20 bytes, and likewise a sniff_tcp structure is 20 bytes.&nbsp; The u_char 
pointer is really just a variable containing an address in memory.&nbsp; That's 
what a pointer is; it points to a location in memory.&nbsp; For the sake of 
simplicity, we'll say that the address this pointer is set to is the value 
X.&nbsp; Well, if our three structures are just sitting in line, the first of 
them (sniff_ethernet) being located in memory at the address X, then we can 
easily find the address of the other structures.&nbsp; So lets make a 
chart:</FONT></P>
<TABLE id=AutoNumber1 style="BORDER-COLLAPSE: collapse" borderColor=#111111 
cellSpacing=0 cellPadding=0 width="100%" border=1>
  <TBODY>
  <TR>
    <TD align=middle width="50%"><B><FONT face=Verdana 
      size=1>Variable</FONT></B></TD>
    <TD align=middle width="50%"><B><FONT face=Verdana size=1>Location (in 
      bytes)</FONT></B></TD></TR>
  <TR>
    <TD width="50%"><FONT face=Verdana size=1>sniff_ethernet</FONT></TD>
    <TD width="50%"><FONT face=Verdana size=1>X</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face=Verdana size=1>sniff_ip</FONT></TD>
    <TD width="50%"><FONT face=Verdana size=1>X + 14</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face=Verdana size=1>sniff_tcp</FONT></TD>
    <TD width="50%"><FONT face=Verdana size=1>X + 14 + 20</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face=Verdana size=1>payload</FONT></TD>
    <TD width="50%"><FONT face=Verdana size=1>X + 14 + 20 + 
  20</FONT></TD></TR></TBODY></TABLE>
<P><FONT face=Verdana size=1>The sniff_ethernet structure, being the first in 
line, is simply at location X.&nbsp; sniff_ip, who follows directly after 
sniff_ethernet, is at the location X, plus however much space sniff_ethernet 
consumes (14 in this example).&nbsp; sniff_tcp is after both sniff_ip and 
sniff_ethernet, so it is location at X plus the sizes of sniff_ethernet and 
sniff_ip (14 and 20 byes, respectively).&nbsp; Lastly, the payload (which isn't 
really a structure, just a character string) is located after all of 
them.</FONT></P>
<P><FONT face=Verdana size=1><B>Note:</B> It is important that you not assume 
your variables will have these sizes.&nbsp; You should always use the sizeof() 
function to ensure that your sizes are accurate.&nbsp; This is because the 
members of each of these structures can have different sizes on different 
platforms.</FONT></P>
<P><FONT face=Verdana size=1>So at this point, we know how to set our callback 
function, call it, and find out the attributes about the packet that has been 
sniffed.&nbsp; It's now the time you have been waiting for: writing a useful 
packet sniffer.&nbsp; Because of the length of the source code, I'm not going to 
include it in the body of this document.&nbsp; Simply download <A 
href="http://www.tcpdump.org/sniffer.c">sniffer.c</A> and try it out.</FONT></P>
<P><FONT face=Verdana size=2>Wrapping Up<BR></FONT><FONT face=Verdana size=1>At 
this point you should be able to write a sniffer using pcap.&nbsp; You have 
learned the basic concepts behind opening a pcap session, learning general 
attributes about it, sniffing packets, applying filters, and using 
callbacks.&nbsp; Now it's time to get out there sniff those wires!</FONT></P>
<P><FONT face=Verdana size=1>This document is Copyright 2002 Tim Carstens.&nbsp; 
All rights reserved.&nbsp; Redistribution and use, with or without modification, 
are permitted provided that the following conditions are met:&nbsp; 1. 
Redistribution must retain the above copyright notice and this list of 
conditions.&nbsp; 2. The name of Tim Carstens may not be used to endorse or 
promote products derived from this document without specific prior written 
permission.<BR>/* Insert 'wh00t' for the BSD license here 
*/</FONT></P></BODY></HTML>
