/** @ingroup wpcap
 */


/** @defgroup wpcap_tut WinPcap tutorial: a step by step guide to create a capture application 
 *  @{

<b>Introduction</b>

This document will guide you in the development of a simple program that captures the network traffic and displays a brief summary of every UDP packet transiting on the wire. We display only UDP (and not for example TCP) for simplicity, since UDP is a straightforward protocol.
The program will print the timestamp, the length, the source and destination addresses, the source and destination ports of every UDP packet.
It will use libpcap functions (that are included in WinPcap as well), so it will be portable under all the platforms supported by this library, i.e. the great part of the Windows and Unix flavours.
The tutorial will show how:
- get the list of the network adapters
- open a network adapter for capture
- receive the packets from the adapter
- filter the network traffic
- handle the packets and display their content

A basic knowledge of C programming is required. Also, since this is a packet capture tutorial, good knowledge of networks is assumed.

<b>Obtaining the device list</b>

First of all, we need to know the list of the network adapters suitable for packet capture and, eventually, present it to the user. Libpcap provides the pcap_findalldevs() function for this purpose: this function returns a linked list of pcap_if structures, each of which contains comprehensive information about an adapter. In particular the fields \e name and \e description contain the name and a human readable description of the device.

The following code retrieves the adapter list and shows on the screen, printing an error if no adapters are found. Click on the code to see detailed documentation.

\code
#include "pcap.h"

main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int i=0;
	char errbuf[PCAP_ERRBUF_SIZE];
	
	/* Retrieve the device list */
	if (pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs;d;d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else			printf(" (No description available)\n");
	}
	
	if(i==0)
	{
		printf("\nNo interfaces found! Make sure WinPcap is installed.\n");
		return;
	}

	/* We don't need any more the device list. Free it */
	pcap_freealldevs(alldevs);
}
\endcode

Some comments about this code.

First of all, pcap_findalldevs(), like the great part of the libpcap functions, has an \e errbuf parameter. This parameter points to a string filled by libpcap with a description of the error if something goes wrong.Second, note that not all the OSes supported by libpcap provide a description of the network interfaces, therefore we must consider the case in which \e description is null: we print the string "No description available" in that situation.
Note also that we free the list with pcap_freealldevs() once when we have finished with it.

Let's try to compile and run the code of this first sample. In order to compile it, under Unix you simply issue a:

gcc -o udpdump udpdump.c -lpcap

On Windows, you will need to create a project, following the instruction in the \ref wpcapsamps section of this manual. However, I suggest you to use the WinPcap developer's pack (available in the WinPcap website), that provides some properly configured sample projects plus all the includes and libraries needed by the application. 

Assuming we have compiled the program, we run it. On my WinXP workstation, the result is

<tt>
1. \Device\Packet_{4E273621-5161-46C8-895A-48D0E52A0B83} (Realtek RTL8029(AS) Ethernet Adapt) \n
2. \Device\Packet_{5D24AE04-C486-4A96-83FB-8B5EC6C7F430} (3Com EtherLink PCI) 
</tt>

As you can see, the name of the network adapters (that will be passed to libpcap when opening the devices) under Windows are quite unreadable, so the description near them is very useful.

<b>Opening an adapter and capturing the packets</b>

Let's complicate a bit the previous sample, adding the ability to open an adapter, capture the transiting traffic and print some information on every packet transiting on the network.

The function that opens a capture device is pcap_open_live(). Among its parameters, \e snaplen and \e promisc deserve a better explanation. 

\e snaplen specifies the portion of the packet to capture. On some OSes (like xBSD and Win32), the packet driver gives the possibility to capture only a part of the packets: this decreases the data to copy and therefore improves the efficiency of the capture process. In this case we use a value (65536) higher than the greatest MTU that we could encounter, in this way we are sure that the application will always receive the whole packet.

\e promisc specifies if the adapter will be put in promiscuous mode. Normally, an adapter extracts from the network only the traffic to or from it. The traffic among other hosts is ignored, also if the adapter is on a shared medium. On the other hand, when the adapter is in promiscuous mode it accepts the whole traffic: this means that on shared media (like non-switched Ethernet) the sniffer will be able to capture the packets of other hosts.

\code
include "pcap.h"

/* prototype of the packet handler */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);

main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int inum;
	int i=0;
	pcap_t *adhandle;
	char errbuf[PCAP_ERRBUF_SIZE];
	
	/* Retrieve the device list */
	if (pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}

	if(i==0)
	{
		printf("\nNo interfaces found! Make sure WinPcap is installed.\n");
		return -1;
	}
	
	printf("Enter the interface number (1-%d):",i);
	scanf("%d", &inum);
	
	if(inum < 1 || inum > i)
	{
		printf("\nInterface number out of range.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* Jump to the selected adapter */
	for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
	
	/* Open the adapter */
	if ( (adhandle= pcap_open_live(d->name,	// name of the device
							 65536,		// portion of the packet to capture. 
										// 65536 grants that the whole packet will be captured on all the MACs.
							 1,			// promiscuous mode
							 1000,		// read timeout
							 errbuf		// error buffer
							 ) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by WinPcap\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	printf("\nlistening on %s...\n", d->description);

	/* At this point, we don't need any more the device list. Free it */
	pcap_freealldevs(alldevs);
	
	/* start the capture */
	pcap_loop(adhandle, 0, packet_handler, NULL);

	return 0;
}


/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	struct tm *ltime;
	char timestr[16];

	/* convert the timestamp to readable format */
	ltime=localtime(&header->ts.tv_sec);
	strftime( timestr, sizeof timestr, "%H:%M:%S", ltime);

	printf("%s,%.6d len:%d\n", timestr, header->ts.tv_usec, header->len);

}
\endcode

The capture can be started with pcap_dispatch() or pcap_loop(). The two functions are very similar, the difference is that pcap_ dispatch() is granted to return when the timeout set with pcap_open_live() expires, also if no packets arrived meanwhile, while pcap_loop() doesn't return until \e cnt packets have been captured, so it can block for an arbitrary period. We use pcap_loop() in this sample.

pcap_loop() has a \e callback parameter, pointing to a function that will receive the packets, packet_handler in this case. This function is invoked by libpcap for every new packet coming from the network and receives a generic argument (corresponding to the \e user parameter of pcap_loop()), an header with some information on the packet like the timestamp and the length, and finally the actual data of the packet including the various protocol headers.

The code just proposed extracts from the header the timestamp and the length of the packet and prints them on the screen.

<b>Filtering the traffic</b>

Since we want to display the UDP packets transiting on the wire, a way to filter the captured packets and keep only the UDP ones would be very useful. Libpcap offers a powerful and very efficient filtering engine, that is (usually) deeply integrated with the capture mechanism provided by the OS. The functions to use are pcap_compile() and pcap_setfilter().

pcap_compile() compiles a filter, i.e. takes a string with an high level boolean expression and produces a low-level filtering program that can be interpreted by the packet driver. The syntax of the boolean expression can be found in the \ref language section of this documantation.

pcap_setfilter() associates a filter to a capture session.

The following code shows how to compile and set a filter. Note that we must retrieve the netmask from the pcap_if structure that describes the adapter, because pcap_compile() requires it.

The filter passed to pcap_compile() is "ip and udp", that means "keep only the udp packets encapsulated in ipv4 and deliver them to the application".

\code
	if(d->addresses != NULL)
		/* Retrieve the mask of the first address of the interface */
		netmask=((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
	else
		/* If the interface is without addresses we suppose to be in a C class network */
		netmask=0xffffff; 


	//compile the filter
	if(pcap_compile(adhandle, &fcode, "ip and udp", 1, netmask) <0 ){
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	//set the filter
	if(pcap_setfilter(adhandle, &fcode)<0){
		fprintf(stderr,"\nError setting the filter.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
\endcode

<b>Interpreting the packets</b>

Now that we are able to sniff and filter the traffic, we must do the real job, i.e. we must handle and display the captured packets. Our application will print a summary of the UDP traffic on the screen, using the standard I/O functions of the C language. Let's give a look at the code.

\code
include "pcap.h"

typedef struct ip_address{
	u_char byte1;
	u_char byte2;
	u_char byte3;
	u_char byte4;
}ip_address;


typedef struct ip_header{
	u_char	ver_ihl;		// Version (4 bits) + Internet header length (4 bits)
	u_char	tos;			// Type of service 
	u_short tlen;			// Total length 
	u_short identification; // Identification
	u_short flags_fo;		// Flags (3 bits) + Fragment offset (13 bits)
	u_char	ttl;			// Time to live
	u_char	proto;			// Protocol
	u_short crc;			// Header checksum
	ip_address	saddr;		// Source address
	ip_address	daddr;		// Destination address
	u_int	op_pad;			// Option + Padding
}ip_header;

typedef struct udp_header{
	u_short sport;			// Source port
	u_short dport;			// Destination port
	u_short len;			// Datagram length
	u_short crc;			// Checksum
}udp_header;

/* prototype of the packet handler */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);


main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int inum;
	int i=0;
	pcap_t *adhandle;
	char errbuf[PCAP_ERRBUF_SIZE];
	u_int netmask;
	char packet_filter[] = "ip and udp";          
	struct bpf_program fcode;
  
	/* Retrieve the device list */
	if (pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}

	if(i==0)
	{
		printf("\nNo interfaces found! Make sure WinPcap is installed.\n");
		return -1;
	}
	
	printf("Enter the interface number (1-%d):",i);
	scanf("%d", &inum);
	
	if(inum < 1 || inum > i)
	{
		printf("\nInterface number out of range.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* Jump to the selected adapter */
	for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
	
	/* Open the adapter */
	if ( (adhandle= pcap_open_live(d->name,	// name of the device
							 65536,		// portion of the packet to capture. 
										// 65536 grants that the whole packet will be captured on all the MACs.
							 1,			// promiscuous mode
							 1000,		// read timeout
							 errbuf		// error buffer
							 ) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by WinPcap\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* Check the link layer. We support only Ethernet for simplicity. */
	if(pcap_datalink(adhandle) != DLT_EN10MB)
	{
		fprintf(stderr,"\nThis program works only on Ethernet networks.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	if(d->addresses != NULL)
		/* Retrieve the mask of the first address of the interface */
		netmask=((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
	else
		/* If the interface is without addresses we suppose to be in a C class network */
		netmask=0xffffff; 


	//compile the filter
	if(pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) <0 ){
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	//set the filter
	if(pcap_setfilter(adhandle, &fcode)<0){
		fprintf(stderr,"\nError setting the filter.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	printf("\nlistening on %s...\n", d->description);
	
	/* At this point, we don't need any more the device list. Free it */
	pcap_freealldevs(alldevs);
	
	/* start the capture */
	pcap_loop(adhandle, 0, packet_handler, NULL);
	
	return 0;
}

/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	struct tm *ltime;
	char timestr[16];
	ip_header *ih;
	udp_header *uh;
	u_int ip_len;
	u_short sport,dport;

	/* convert the timestamp to readable format */
	ltime=localtime(&header->ts.tv_sec);
	strftime( timestr, sizeof timestr, "%H:%M:%S", ltime);

	/* print timestamp and length of the packet */
	printf("%s.%.6d len:%d ", timestr, header->ts.tv_usec, header->len);

	/* retireve the position of the ip header */
	ih = (ip_header *) (pkt_data +
		14); //length of ethernet header

	/* retireve the position of the udp header */
	ip_len = (ih->ver_ihl & 0xf) * 4;
	uh = (udp_header *) ((u_char*)ih + ip_len);

	/* convert from network byte order to host byte order */
	sport = htons( uh->sport );
	dport = htons( uh->dport );

	/* print ip addresses and udp ports */
	printf("%d.%d.%d.%d.%d -> %d.%d.%d.%d.%d\n",
		ih->saddr.byte1,
		ih->saddr.byte2,
		ih->saddr.byte3,
		ih->saddr.byte4,
		sport,
		ih->daddr.byte1,
		ih->daddr.byte2,
		ih->daddr.byte3,
		ih->daddr.byte4,
		dport);
}
\endcode

We have created a couple of structs that describe the IP and UDP headers. These structs are used by packet_handler() to locate the various header fields. 

First of all, packet_handler() skips the MAC header. For simplicity, we made a check on the MAC layer with pcap_datalink(), therefore we are sure that we are on an Ethernet network and that the MAC header is 14 bytes.

The IP header is located just after the MAC one. We extract from it the source and destination addresses. 

Reaching the UDP header is a bit more complex, because the IP header hasn't a fixed length. Therefore, we use the internet header length field to know its dimension. At this point, we print the source and destination ports from the UDP header.

The result will be something like:

<tt>
1. \Device\Packet_{4E273621-5161-46C8-895A-48D0E52A0B83} (Realtek RTL8029(AS) Ethernet Adapt) \n
2. \Device\Packet_{A7FD048A-5D4B-478E-B3C1-34401AC3B72F} (Xircom
t 10/100 Adapter) \n
Enter the interface number (1-2):2\n

listening on Xircom CardBus Ethernet 10/100 Adapter... \n
16:13:15.312784 len:87 130.192.31.67.2682 -> 130.192.3.21.53
16:13:15.314796 len:137 130.192.3.21.53 -> 130.192.31.67.2682
16:13:15.322101 len:78 130.192.31.67.2683 -> 130.192.3.21.53
</tt>

In which every line represents a different packet.

@}*/
